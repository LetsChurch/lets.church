// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: auth.sql

package data

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const changePassword = `-- name: ChangePassword :exec
UPDATE app_user SET password=$1 WHERE id=$2
`

type ChangePasswordParams struct {
	Password string
	ID       pgtype.UUID
}

func (q *Queries) ChangePassword(ctx context.Context, arg ChangePasswordParams) error {
	_, err := q.db.Exec(ctx, changePassword, arg.Password, arg.ID)
	return err
}

const createUser = `-- name: CreateUser :one
INSERT INTO app_user (username, password, full_name, updated_at)
VALUES ($1, $2, $3, NOW())
RETURNING id
`

type CreateUserParams struct {
	Username pgtype.Text
	Password string
	FullName pgtype.Text
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Username, arg.Password, arg.FullName)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const createUserEmail = `-- name: CreateUserEmail :one
INSERT INTO app_user_email (app_user_id, email)
VALUES ($1, $2)
RETURNING id, key
`

type CreateUserEmailParams struct {
	AppUserID pgtype.UUID
	Email     pgtype.Text
}

type CreateUserEmailRow struct {
	ID  pgtype.UUID
	Key pgtype.UUID
}

func (q *Queries) CreateUserEmail(ctx context.Context, arg CreateUserEmailParams) (CreateUserEmailRow, error) {
	row := q.db.QueryRow(ctx, createUserEmail, arg.AppUserID, arg.Email)
	var i CreateUserEmailRow
	err := row.Scan(&i.ID, &i.Key)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT
  u.id, u.username, u.password, u.full_name, u.avatar_path, u.avatar_blurhash, u.created_at, u.updated_at, u.deleted_at, u.role,
  (SELECT e.email
   FROM app_user_email e
   WHERE e.app_user_id = u.id
     AND e.verified_at IS NOT NULL
   ORDER BY e.verified_at DESC
   LIMIT 1) AS email
FROM app_user u
LEFT JOIN app_user_email e ON e.app_user_id = u.id
WHERE u.username = $1
   OR e.email = $1
LIMIT 1
`

type GetUserRow struct {
	ID             pgtype.UUID
	Username       pgtype.Text
	Password       string
	FullName       pgtype.Text
	AvatarPath     pgtype.Text
	AvatarBlurhash pgtype.Text
	CreatedAt      pgtype.Timestamp
	UpdatedAt      pgtype.Timestamp
	DeletedAt      pgtype.Timestamp
	Role           AppUserRole
	Email          pgtype.Text
}

func (q *Queries) GetUser(ctx context.Context, identifier pgtype.Text) (GetUserRow, error) {
	row := q.db.QueryRow(ctx, getUser, identifier)
	var i GetUserRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.FullName,
		&i.AvatarPath,
		&i.AvatarBlurhash,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Role,
		&i.Email,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT u.id, u.username, u.password, u.full_name, u.avatar_path, u.avatar_blurhash, u.created_at, u.updated_at, u.deleted_at, u.role
FROM app_user u
LEFT JOIN app_user_email e ON e.app_user_id = u.id
WHERE e.email = $1
LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, identifier pgtype.Text) (AppUser, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, identifier)
	var i AppUser
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.FullName,
		&i.AvatarPath,
		&i.AvatarBlurhash,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Role,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT
  u.id, u.username, u.password, u.full_name, u.avatar_path, u.avatar_blurhash, u.created_at, u.updated_at, u.deleted_at, u.role,
  (SELECT e.email
   FROM app_user_email e
   WHERE e.app_user_id = u.id
     AND e.verified_at IS NOT NULL
   ORDER BY e.verified_at DESC
   LIMIT 1) AS email
FROM app_user u
LEFT JOIN app_user_email e ON e.app_user_id = u.id
WHERE u.id = $1
`

type GetUserByIdRow struct {
	ID             pgtype.UUID
	Username       pgtype.Text
	Password       string
	FullName       pgtype.Text
	AvatarPath     pgtype.Text
	AvatarBlurhash pgtype.Text
	CreatedAt      pgtype.Timestamp
	UpdatedAt      pgtype.Timestamp
	DeletedAt      pgtype.Timestamp
	Role           AppUserRole
	Email          pgtype.Text
}

func (q *Queries) GetUserById(ctx context.Context, id pgtype.UUID) (GetUserByIdRow, error) {
	row := q.db.QueryRow(ctx, getUserById, id)
	var i GetUserByIdRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.FullName,
		&i.AvatarPath,
		&i.AvatarBlurhash,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Role,
		&i.Email,
	)
	return i, err
}

const userExists = `-- name: UserExists :one
SELECT EXISTS (SELECT 1 FROM app_user WHERE username = $1)
`

func (q *Queries) UserExists(ctx context.Context, username pgtype.Text) (bool, error) {
	row := q.db.QueryRow(ctx, userExists, username)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const verifyEmail = `-- name: VerifyEmail :one
WITH updated_rows AS (
  UPDATE app_user_email SET "verifiedAt"=NOW()
  WHERE id=$1
  AND app_user_id = $2
  AND key=$3
  AND "verifiedAt" IS NULL
  RETURNING id, app_user_id, email, key, "verifiedAt"
)
SELECT COUNT(*) FROM updated_rows
`

type VerifyEmailParams struct {
	EmailID   pgtype.UUID
	AppUserID pgtype.UUID
	Key       pgtype.UUID
}

func (q *Queries) VerifyEmail(ctx context.Context, arg VerifyEmailParams) (int64, error) {
	row := q.db.QueryRow(ctx, verifyEmail, arg.EmailID, arg.AppUserID, arg.Key)
	var count int64
	err := row.Scan(&count)
	return count, err
}
